{"./":{"url":"./","title":"Introduction","keywords":"","body":"Notes github pages gitbook pages "},"ROS/":{"url":"ROS/","title":"ROS","keywords":"","body":"ROS机器人操作系统 "},"ROS/ROS开发环境.html":{"url":"ROS/ROS开发环境.html","title":"ROS开发环境","keywords":"","body":"ROS开发环境 1. 版本选择 ROS版本 Ubuntu 版本 ROS Kinetic Kame Ubuntu 16.04 ROS Melodic Morenia Ubuntu 18.04 ROS Noetic Ninjemys Ubuntu 20.04 ros的各个版本之间不相互兼容，安装前需要注意版本对应 2. 添加软件源 使用中科大的镜像源安装ROS sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main\" > /etc/apt/sources.list.d/ros-latest.list' 3. 添加keys sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 apt-key用于管理Debian Linux系统中的软件包密钥。每个发布的deb包，都是通过密钥认证的，apt-key用来管理密钥。 4. 更新软件源 sudo apt-get update sudo apt-get upgrade update是更新软件列表，upgrade是更新已安装的软件 参考apt-get update与upgrade的区别 5. 安装ROS ros官方提供四种安装方式，Ubuntu16.04安装Kinetic版本 桌面完整版安装 包括ROS、rqt、rviz、通用机器人函数库、2D/3D仿真器、导航以及2D/3D感知功能 sudo apt-get install ros-kinetic-desktop-full 桌面版安装 包含ROS、rqt、rviz以及通用机器人函数库 sudo apt-get install ros-kinetic-desktop 基础版安装 包含ROS核心软件包、构建工具以及通信相关的程序库，无GUI工具 sudo apt-get install ros-kinetic-ros-base 单独软件包安装 可以用来安装指定软件包，这种安装方式在运行ROS缺少某些package依赖时会经常用到。 sudo apt-get install ros-kinetic-PACKAGE 用包名替代上述命令中的PACKAGE可安装相应的功能包 6. 配置ROS 6.1. 初始化rosdep sudo rosdep init sudo rosdep update 这里可能会因为github站点网络链接问题而报错，使用代理即可解决 6.2. ROS环境变量设置 echo \"source /opt/ros/kinetic/setup.bash\" >> ~/.bashrc 相当于每次打开终端都执行遍source命令 6.3. 安装rosinstall sudo apt-get install python-rosinstall 7. 测试ROS环境 7.1. 启动roscore roscore 成功启动后如下图所示 7.2. 启动海龟测试节点 rosrun turtlesim turtlesim_node turtlesim_node节点是模拟海龟运动的节点 7.3. 启动控制节点 rosrun turtlesim turtle_teleop_key turtle_teleop_key节点是键盘控制节点 "},"ROS/二进制包和源码包.html":{"url":"ROS/二进制包和源码包.html","title":"二进制包和源码包","keywords":"","body":"二进制包和源码包 1. 区别 二进制包是可以直接通过使用sudo apt-get install命令进行安装的，能够直接使用而无需重新编译。 源代码包是程序的源代码，能够根据具体情况进行修改，再经过计算机编译，生成二进制可执行文件才能运行。 区别 二进制包 源代码包 下载方式 sudo apt-get install git clone ROS包存放位置 /opt/ros/kinetic/ 随意存放，一般为工作目录 应用场景 基础软件 第三方程序，需要修改的源码 2. ROS二进制包的安装 例如安装GMapping包 sudo apt-get install ros-kinetic-slam-gmapping 所有apt官方的ROS功能包命名均为ros-版本代号-功能包名, kinect为Ubuntu16.04下的ROS的名称 3. 源码安装 以ROS-Academy-for-Beginners为例进行安装 3.1. 创建工作空间 mkdir -p ~/tutorial_ws/src cd tutorial_ws/src 3.2. 下载源码 git clone https://github.com/DroidAITech/ROS-Academy-for-Beginners.git 3.3. 安装依赖 在ros工作空间内安装全部包的依赖 cd ~/tutorial_ws rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 另外需要Gazebo的版本高于 7.0，可通过gazebo -v查看当前版本，升级步骤如下 sudo sh -c 'echo \"deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\" > /etc/apt/sources.list.d/gazebo-stable.list' wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt-get update sudo apt-get install gazebo7 3.4. 编译 cd ~/tutorial_ws catkin_make source ~/tutorial_ws/devel/setup.bash source命令在每一次打开新终端的时候都要执行一次，故可以写入~/.bashrc catkin_make是一个编译构建系统 3.5. 运行仿真程序 roslaunch robot_sim_demo robot_spawn.launch "},"ROS/ROS工作空间.html":{"url":"ROS/ROS工作空间.html","title":"ROS工作空间","keywords":"","body":"ROS工作空间 1. Catkin编译系统 源码需要编译、链接等步骤才能生成二进制可执行文件，对于 ROS 等大型项目而言，需要管理项目结构，进行自动化编译等。 Catkin 是 ROS 对 CMake 进行拓展之后的，CMake 能够生成makefile文件，进而能够控制编译的过程 Catkin 编译系统的层级结构如图 1.1. Catkin编译流程 在工作空间catkinws/src/下进行递归查询每一个ROS包 ROS包中有package.xml和CMakeLists.txt文件，则根据CMakeLists.txt生成相应的makefile文件 再 make 进行编译 相当于catkin_make是将cmake与make进行了合并操作，同时提高了跨项目依赖性 1.2. 使用catkin_make进行编译 必须要在工作空间的目录下执行catkin_make，之后需要source命令更新环境变量，否则rosrun无法执行ros包 cd ~/catkinws catkin_make source ./devel/setup.bash 2. ROS工作空间结构 ─ build │ ├── catkin │ │ └── catkin_generated │ │ └── version │ │ └── package.cmake │ ├── ...... │ ├── catkin_make.cache │ ├── CMakeCache.txt │ ├── CMakeFiles │ │ ├── ...... ├── devel │ ├── env.sh │ ├── lib │ ├── setup.bash │ ├── setup.sh │ ├── _setup_util.py │ └── setup.zsh └── src └── CMakeLists.txt -> /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake src/用于存放各种package，其中同一类多个功能包可以存放在一个子目录下 build/用于存放编译过程中的中间文件，缓存信息等 devel/用于存放生成的目标文件，包括可执行文件，静态链接库，动态链接库等 src/下的源代码，经过编译生成中间文件，存在build/下，build/下的文件再经过链接等处理，最后生成可执行文件，库文件等，存放在devel/ src/下允许存在多个package，在ROS工作空间下的各个package可以在子目录下 "},"ROS/packages.html":{"url":"ROS/packages.html","title":"packages","keywords":"","body":"packages 1. package结构 package是catkin编译的基本单元，一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等） ├── CMakeLists.txt #package的编译规则(必须) ├── package.xml #package的描述信息(必须) ├── src/ #源代码文件 ├── include/ #C++头文件 ├── scripts/ #可执行脚本 ├── msg/ #自定义消息 ├── srv/ #自定义服务 ├── action/ #自定义服务 ├── models/ #3D模型文件 ├── urdf/ #urdf文件 ├── launch/ #launch文件 ├── config/ #参数配置文件 CMakeLists.txt文件和package.xml文件，这两个文件定义了package CMakeLists.txt定义的是package的编译规则，用到的依赖关系等 package.xml定义的是功能包相关的信息，描述package的包名、版本号、作者、依赖等信息 src/存放的是源代码文件，主要是cpp源码以及python的module文件 include/存放的是hpp头文件 scripts/存放的是脚本文件，shell脚本、python脚本等 msg/存放的是自定义格式的消息文件（*.msg） srv/存放的是自定义格式的服务文件（*.srv） action/存放的是自定义格式的动作文件（*.action） models/存放机器人或仿真场景的3D模型（.sda, .stl, .dae等） urdf/存放机器人的模型描述（.urdf, .xacro） launch/存放的是启动文件（*.launch） config/存放的是全局配置文件（*.yaml） 2. 创建package 创建一个package需要在catkin_ws/src/下，用到catkin_create_pkg命令，相当于脚手架，搭建package框架结构 catkin_create_pkg package depends 其中package是包名，depends是依赖的包名，可以依赖多个软件包。 例如，新建一个package叫做test_pkg，依赖roscpp、rospy、std_msgs(常用依赖)。 catkin_create_pkg test_pkg roscpp rospy std_msgs 此时目录结构为 ├── CMakeLists.txt ├── include │ └── test_pkg ├── package.xml └── src catkin_create_pkg默认创建好了CMakeLists.txt和package.xml，并将项目依赖项添加到了package.xml 3. package相关的命令 3.1. rospack rospack是ros的package管理工具 rostopic命令 作用 rospack help 显示rospack的用法 rospack list 列出本机所有package rospack depends [package] 显示package的依赖包 rospack find [package] 定位某个package rospack profile 刷新所有package的位置记录 package缺省则默认为当前目录下的package 3.2. roscd roscd命令类似与Linux系统的cd，改进之处在于roscd可以直接改变目录到ROS的软件包目录下 3.3. rosls rosls也可以视为Linux指令ls的改进版，可以直接在任意目录下列出相应ROS软件包的内容 rosls [pacakge]列出pacakge下的文件 3.4. rosdep rosdep是用于管理ROS package依赖项的命令行工具 rosdep命令 作用 rosdep check [pacakge] 检查package的依赖是否满足 rosdep install [pacakge] 安装pacakge的依赖 rosdep db 生成和显示依赖数据库 rosdep init 初始化/etc/ros/rosdep中的源 rosdep keys 检查package的依赖是否满足 rosdep update 更新本地的rosdep数据库 一个较常使用的命令是rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y，用于安装工作空间中src路径下所有package的依赖项（由pacakge.xml文件指定） 4. Metapackage元功能包 4.1. Metapackage介绍 Metapackage是一个功能包集合，把几个相近的功能模块、软件包放到一起，之前叫Stack。元功能包本身没有实质性的功能，但是依赖于多个软件包，相当于一个集合 ROS里常见的Metapacakge有： Metapacakge名称 描述 链接 navigation 导航相关的功能包集 https://github.com/ros-planning/navigation moveit 运动规划相关的（主要是机械臂）功能包集 https://github.com/ros-planning/moveit image_pipeline 图像获取、处理相关的功能包集 https://github.com/ros-perception/image_common vision_opencv ROS与OpenCV交互的功能包集 https://github.com/ros-perception/vision_opencv turtlebot Turtlebot机器人相关的功能包集 https://github.com/turtlebot/turtlebot pr2_robot pr2机器人驱动功能包集 https://github.com/PR2/pr2_robot ... ... ... 以上列举了一些常见的功能包集，例如navigation、turtlebot，他们都是用于某一方面的功能，以navigation metapackage（官方介绍里仍然沿用stack的叫法）为例，它包括了以下软件包： 包名 功能 navigation Metapacakge，依赖以下所有pacakge amcl 定位 fake_localization 定位 map_server 提供地图 move_base 路径规划节点 nav_core 路径规划的接口类 base_local_planner 局部规划 dwa_local_planner 局部规划 ... ... 4.2. Metapackage结构 我们以ROS-Academy-for-beginners为例介绍meteapckage的写法，在教学包内，有一个ros-academy-for-beginners软件包，该包即为一个metapacakge，其中有且仅有两个文件：CMakeLists.txt和pacakge.xml。 CMakeLists.txt写法如下： cmake_minimum_required(VERSION 2.8.3) project(ros_academy_for_beginners) find_package(catkin REQUIRED) catkin_metapackage() #声明本软件包是一个metapacakge pacakge.xml写法如下： ros_academy_for_beginners 17.12.4 -------------------------------------------------------------------------- A ROS tutorial for beginner level learners. This metapacakge includes some demos of topic, service, parameter server, tf, urdf, navigation, SLAM... It tries to explain the basic concepts and usages of ROS. -------------------------------------------------------------------------- Chai Changkun Chai Changkun BSD http://http://www.droid.ac.cn catkin navigation_sim_demo param_demo robot_sim_demo service_demo slam_sim_demo tf_demo topic_demo metapacakge中的以上两个文件和普通pacakge不同点是： CMakeLists.txt:加入了catkin_metapackage()宏，指定本软件包为一个metapacakge。 package.xml:标签将所有软件包列为依赖项，标签中添加标签声明。 metapacakge在我们实际开发一个大工程时可能有用 "},"ROS/package.xml.html":{"url":"ROS/package.xml.html","title":"package.xml","keywords":"","body":"package.xml 1. package.xml作用 package.xml也是一个catkin的package必备文件，它是这个软件包的描述文件，用于描述pacakge的基本信息。pacakge.xml包含了package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。 实际上rospack find、rosdep等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的package.xml文件。它为用户提供了快速了解一个pacakge的渠道。 2. package.xml写法 目前Indigo、Kinetic、Lunar等版本的ROS都同时支持两种版本的package.xml，所以无论选format1还是format2都可以。 参考解析 package.xml 文件 2.1. format2 在新版本（format2）中，包含的标签为： 标签名 作用 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 指定依赖项为编译、导出、运行需要的依赖，最常用 编译依赖项 导出依赖项 运行依赖项 测试用例依赖项 文档依赖项 相当于、、 ,相当于将之前的build和run依赖项描述进行了细分。 每个ROS功能包都至少有一个依赖项，一个指定了构建、执行、测试、文档依赖项的 xml 文件如下： sensor_funsion 1.2.3 This package fusion point cloud and image. www.xxx.com DLonng xxx BSD catkin roscpp std_msgs message_generation message_runtime rospy python-mock doxygen 2.2. format1 pacakge.xml遵循xml标签文本的写法，由于版本更迭原因，现在有两种格式并存（format1与format2），不过区别不大。老版本（format1）的pacakge.xml通常包含以下标签: 标签名 作用 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 编译依赖项 运行依赖项 测试用例依赖项 sensor_funsion 1.2.3 This package fusion point cloud and image. www.xxx.com DLonng xxx BSD 3. pacakge.xml例子 为了说明pacakge.xml写法，还是以turtlesim软件包为例，其pacakge.xml文件内容如下，我们添加了相关的注释： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs qtbase5-dev message_generation qt5-qmake rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs geometry_msgs libqt5-core libqt5-gui message_runtime rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs 以上内容是老版本（format1）的写法，如果要写成新版本（format2）则可以改为： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs qtbase5-dev message_generation qt5-qmake libqt5-core libqt5-gui message_runtime "},"ROS/CMakeLists.txt.html":{"url":"ROS/CMakeLists.txt.html","title":"CMakeLists.txt","keywords":"","body":"CMakeLists.txt CMakeLists.txt原本是Cmake编译系统的规则文件，而Catkin编译系统基本沿用了CMake的编译风格，只是针对ROS工程添加了一些宏定义。所以在写法上，catkin的CMakeLists.txt与CMake的基本一致。 CMake参考资料 cmake-practice.pdf 解析CMakeList.txt文件 这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等流程。所以CMakeLists.txt非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的CMakeLists.txt，然后按照规则来编译构建。 turtlesim的CMakeLists 以turtlesim小海龟这个pacakge为例，roscd tuetlesim查看，在turtlesim/CMakeLists.txt的写法如下: cmake_minimum_required(VERSION 2.8.3) #CMake至少为2.8.3版 project(turtlesim) #项目(package)名称为turtlesim，在后续文件中可使用变量${PROJECT_NAME}来引用项目名称turltesim find_package(catkin REQUIRED COMPONENTS geometry_msgs message_generation rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs ) #cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如_FOUND, _INCLUDE_DIRS, _LIBRARYIS #此处catkin是必备依赖 其余的geometry_msgs...为组件 find_package(Qt5Widgets REQUIRED) find_package(Boost REQUIRED COMPONENTS thread ) include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS}) #指定C++的头文件路径 link_directories(${catkin_LIBRARY_DIRS}) #指定链接库的路径 add_message_files(DIRECTORY msg FILES Color.msg Pose.msg ) #自定义msg文件 add_service_files(DIRECTORY srv FILES Kill.srv SetPen.srv Spawn.srv TeleportAbsolute.srv TeleportRelative.srv ) #自定义srv文件 generate_messages(DEPENDENCIES geometry_msgs std_msgs std_srvs) #在add_message_files、add_service_files宏之后必须加上这句话，用于生成srv msg头文件/module，生成的文件位于devel/include中 catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs ) # catkin宏命令，用于配置ROS的package配置文件和CMake文件 # 这个命令必须在add_library()或者add_executable()之前调用，该函数有5个可选参数： # (1) INCLUDE_DIRS - 导出包的include路径 # (2) LIBRARIES - 导出项目中的库 # (3) CATKIN_DEPENDS - 该项目依赖的其他catkin项目 # (4) DEPENDS - 该项目所依赖的非catkin CMake项目。 # (5) CFG_EXTRAS - 其他配置选项 set(turtlesim_node_SRCS src/turtlesim.cpp src/turtle.cpp src/turtle_frame.cpp ) set(turtlesim_node_HDRS include/turtlesim/turtle_frame.h ) #指定turtlesim_node_SRCS、turtlesim_node_HDRS变量 qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS}) add_executable(turtlesim_node ${turtlesim_node_SRCS} ${turtlesim_node_MOCS}) # 指定可执行文件目标turtlesim_node target_link_libraries(turtlesim_node Qt5::Widgets ${catkin_LIBRARIES} ${Boost_LIBRARIES}) # 指定链接可执行文件 add_dependencies(turtlesim_node turtlesim_gencpp) add_executable(turtle_teleop_key tutorials/teleop_turtle_key.cpp) target_link_libraries(turtle_teleop_key ${catkin_LIBRARIES}) add_dependencies(turtle_teleop_key turtlesim_gencpp) add_executable(draw_square tutorials/draw_square.cpp) target_link_libraries(draw_square ${catkin_LIBRARIES} ${Boost_LIBRARIES}) add_dependencies(draw_square turtlesim_gencpp) add_executable(mimic tutorials/mimic.cpp) target_link_libraries(mimic ${catkin_LIBRARIES}) add_dependencies(mimic turtlesim_gencpp) # 同样指定可执行目标、链接、依赖 install(TARGETS turtlesim_node turtle_teleop_key draw_square mimic RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}) # 安装目标文件到本地系统 install(DIRECTORY images DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION} FILES_MATCHING PATTERN \"*.png\" PATTERN \"*.svg\") "},"ROS/ROS通信架构.html":{"url":"ROS/ROS通信架构.html","title":"ROS通信架构","keywords":"","body":"ROS通信架构 1. Node & Master ROS通信系统是一个由ROS进程组成的点对点网络，如图所示ROS系统分为一个Master和多个Node节点，Node向Master注册，Node之间的通信则不需要通过Master，可以直接进行点对点的通信。ROS的通信方式主要有： topic话题 service服务 action动作 Parameter Service参数服务器 1.1. Node Node是ROS的最小运行单元，在ROS里每个进程都是一个Node，每个package的可执行文件都是一个Node，代表的是一种功能。对于机器人编程而言，需要对机器人各个功能进行分离，因此最终一个机器人系统会由多个Node组成 机器人多个Node组成的优点 提高系统的鲁棒性，能在某些节点出问题的情况下不影响其他节点 降低系统的耦合程度，提高系统的可移植性和可调试性 1.2. Master Master是ROS的节点管理器，用于管理ROS中的所有Node，Node在启动之后的第一件事就是需要向Master注册，以便能够完成各个节点之间的通信等操作。所以在启动Node之前需要保证Master的工作正常 当一个节点开始发布一个topic，节点将会将topic的名字和数据类型信息传递给Master，Master将会检查是否有其他的节点订阅了这个topic，如果有任何的节点订阅了这个topic，Master将会共享发布者的消息给订阅者节点。 1.3. 分布式ROS 对于单机ROS系统而言，ROS的各个Node和Master可以不用考虑URI问题。但是对于分布式系统而言，ROS系统需要知道每个分布式主机对应的Node的地址（IP和端口）。分布式ROS系统中的Master同样只能有一个，且需要在Node之前启动。 通过设置ROS_MASTER_URI环境变量来完成局域网内主机对Master的定位，进而进行接下来的Node启动等工作 ROS的各个主机之间的通信是通过{主机名}:{端口号}的形式进行通信的，因此需要修改局域网内的ROS主机的host文件来定位 参考文件 ros分布式多机通信 - CSDN ROS分布式多机通信 - 知乎 2. ROS启动流程 2.1. 启动roscore roscore 与此同时启动的还有 rosout rosout是一个节点，主要作用就是日志输出，告之用户当前系统的运行状态，系统运行过程中的error和warning，并将log记录在文件中方便后期复盘 parameter server parameter server是参数服务器，主要作用是维护系统运行中的全局参数，各个节点都可以读取参数服务器中的数据 2.2. 启动Node rosrun启动一个节点 rosrun pkg_name node_name pkg_namepackage名字 node_namepackage下的node名 Node管理相关的命令rosnode rosnode命令 作用 rosnode list 列出当前运行的node信息 rosnode info node_name 显示出node的详细信息 rosnode kill node_name 结束某个node rosnode ping 测试连接节点 rosnode machine 列出在特定机器或列表机器上运行的节点 rosnode cleanup 清除不可到达节点的注册信息 "},"ROS/Launch文件.html":{"url":"ROS/Launch文件.html","title":"Launch文件","keywords":"","body":"Launch 1. 通过Launch文件启动ROS 当一个机器人系统拥有多个Node时，可以使用launch文件来组织这些节点。通过对launch文件的配置，可以达到“一键启动的效果”roslaunch就是一个启动管理器。一般情况下整个系统的启动文件是在{name}_bringup包下的{name}.launch roslaunch pkg_name file_name.launch roslaunch命令会首先检查roscore是否成功启动，即判断节点管理器master是否正常运行如若没有启动会在启动节点之前先启动roscere 2. launch文件语法格式 launch文件本质也是xml文件，因此语法格式满足xml文件的标准，它包括的标签 标签 作用 根标签 需要启动的node及其参数 包含其他launch 指定运行的机器 设置环境变量 定义参数到参数服务器 启动yaml文件参数到参数服务器 定义变量 设定参数映射 设定命名空间 每个标签有多个属性，具体含义参考wiki name 节点重命名，相当于节点的第二个名字，这个可以重复 pkg 节点所在的package名 type 在package里的节点名，使用rosrun命令是的node名 name 变量名 default 默认值（可选） value 变量值（可选） file 格式为$(find pkg_name)/path/filename.xml 3. 示例文件 最简单的launch文件只需要有node即可，比如启动rospy_tutorials包下的talker节点 而在实际应用时的launch文件就复杂一些，robot_sim_demo下的robot_spawn.launch文件如下 robot_spawn.launch中引用的xbot-u.launch.xml文件的内容如下 --> --> "},"ROS/Topic和msg.html":{"url":"ROS/Topic和msg.html","title":"Topic和msg","keywords":"","body":"Topic和msg 1. Topic ROS的Topic通信通常用于实时性、周期性的消息通信，Topic是一个点对点的通信模型，这里的点指的是节点（Node），通信模型是 发布-订阅 模型，要建立通信需要经过几个步骤 发布者（Publisher）和订阅者（Subscriber）节点向Master注册 发布者发布一个话题 Master指挥订阅者进行订阅相应的话题 建立起发布者到订阅者的单向点对点通信 一个Topic可以被多个订阅者订阅，多个发布者也可以向同一个Topic发布消息，订阅者和发布者之间的通信是直接进行的，不经过Master转发，只是订阅者从Master处获取订阅的话题信息，建立通信 Topic通信是异步通信，发布者发布消息之后继续执行相应的工作，不等待任何人反馈，订阅者在收到发布者发布的消息之后，调用回调函数进行消息处理。 参考ROS多个传感器publish同一个Topic 1.1. rostopic命令 命令 作用 rostopic help 帮助，查询相关命令具体用法 rostopic list 列出当前所有的topic rostopic info topic_name 显示某个topic的属性信息 rostopic echo topic_name 显示某个topic的内容 rostopic pub topic_name ... 向某个topic发布内容 rostopic bw topic_name 查看某个topic的带宽 rostopic hz topic_name 查看某个topic的频率 rostopic find topic_type 查找某个类型的topic rostopic type topic_name 查看某个topic的类型(msg) 1.2. 通信示例 机载平台采集并处理摄像头信息，笔记本电脑上对摄像头的数据进行显示，这里有三个节点 Node1摄像头节点 控制摄像头采集数据，运行在机载平台 Node2图像处理节点 对摄像头采集的数据进行处理，保障机器人的后续功能，运行在机载平台 Node3图像显示节点 对摄像头采集的数据在笔记本电脑上进行显示，运行在远程笔记本平台上 三个节点加入ROS通信网络，向Master节点进行注册，Node1摄像头节点启动之后作为发布者开始向/camera_rgb话题发布数据，Node2图像处理节点和Node3图像显示节点启动后作为订阅者，经过Master节点管理器的控制，分别和Node1摄像头节点建立通信 Node1摄像头节点只管发布数据，不关心Node2图像处理节点和Node3图像显示节点是否收到消息、是否处理完消息，同样Node2图像处理节点和Node3图像显示节点只在接收到Node1摄像头节点发布的消息之后对消息进行相应的处理，不关心Node1摄像头节点在什么时候发布消息，处理完消息之后不需要向Node1摄像头节点发送任何反馈，这体现了Topic通信的异步性质 2. Message Topic通信过程中的数据发布与订阅处理等有严格的格式要求，需要预先约定消息的格式，通过Message来确定数据格式，例如上述示例中的/camera_rgb话题，这个话题的消息格式只能是ROS中定义好的RGB图像格式，这种数据格式就是Message。Message定义在msg/下的*.msg文件中 2.1. rosmsg命令 rosmsg命令 作用 rosmsg list 列出系统上所有的msg rosmsg show msg_name 显示某个msg的内容 2.2. 结构与类型 Message有几种基本的数据类型 bool int8 int16 int32 int64 uint float float64 string time duration header array[] 可变长数组 array[C] 固定长度数组 每个*.msg文件的文件名又形成了一个新的数据结构，可以在其他的*.msg文件中直接使用，类似与C语言中的struct结构体 2.3. msg文件示例 ROS定义的Header.msg # 定义数据的参考时间和参考坐标 # 文件位置:std_msgs/Header.msg uint32 seq #数据ID time stamp #数据时间戳 string frame_id #数据的参考坐标系 用户自定义的Vector3.msg # 三维度向量 # 位置:geometry_msgs/Vector3.msg float64 x float64 y float64 z 用户自定义的Quaternion.msg # 消息代表空间中旋转的四元数 # 位置:geometry_msgs/Quaternion.msg float64 x float64 y float64 z float64 w 用户自定义的Imu.msg # 消息包含了从惯性原件中得到的数据，加速度为m/^2，角速度为rad/s # 如果所有的测量协方差已知，则需要全部填充进来 # 如果只知道方差，则只填充协方差矩阵的对角数据即可 # 位置：sensor_msgs/Imu.msg Header header Quaternion orientation float64[9] orientation_covariance Vector3 angular_velocity float64[9] angular_velocity_covariance Vector3 linear_acceleration float64[] linear_acceleration_covariance "},"ROS/Service和srv.html":{"url":"ROS/Service和srv.html","title":"Service和srv","keywords":"","body":"Service和srv 1. Service servivce是一种 请求-查询 的通信模型，适用于那些临时、非周期性的数据需求的节点使用。双向通信，不仅可以发送消息，而且还可以接受反馈。使用service通信，消息的提供者不需要一直向外发送数据，仅在请求方有消息请求的时候才发送数据。 service的通信包括两部分 请求方（Client） 服务提供方（Server） service通信是一种同步通信，请求方向服务方发送一个request，请求方会等待服务方的reply，收到reply之后再进行接下来的工作；服务方在接收到request之后，进行相应的消息处理，并返回一个reply 1.1. 和topic通信方式对比 topic service 通信方式 异步通信 同步通信 通信方向 单向通信 双向通信 实现原理 TCP/IP TCP/IP 通信模型 Publish-Subscribe Request-Reply 映射关系 Publish-Subscribe（多对多） Request-Reply（多对一） 特点 接受者收到数据会回调（Callback） 远程过程调用（RPC）服务器端的服务 应用场景 连续、高频的数据发布 偶尔使用的功能/具体的任务 举例 激光雷达、里程计发布数据 开关传感器、拍照、逆解计算 远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。 1.2. rosservice命令 rosservice 命令 作用 rosservice list 显示服务列表 rosservice info 打印服务信息 rosservice call 使用所提供的args调用服务 rosservice type 打印服务类型 rosservice uri 打印服务ROSRPC uri rosservice find 按服务类型查找服务 rosservice args 打印服务参数 1.3. 通信示例 打开模拟场景roslaunch robot_sim_demo robot_spawn.launch。 输入rosservice list，可以查看当前运行的服务。 例如/gazebo/delete_light服务，是删除光源的操作。 输入rosservice info /gazebo/delete_light查看属性信息。可以看到信息，Node：/gazebo，Type：gazebo_msgs/DeleteLight, Args：Light_name。这里的类型type也就是,传递参数Light_name 输入rosservice call /gazebo/delete_light sun，这里的sun是参数名，使我们模拟场景中的唯一光源太阳。操作完成后可以看到场景中的光线消失。 可以看到终端的回传信息：success: True和sun successfully deleted 这就是双向通信的信息反馈，通知操作已经成功完成。 2. srv 类似msg文件，srv文件是用来描述服务（service）数据类型的，service通信的数据格式定义在*.srv中。它声明了一个服务的通信格式，包括请求(request)和响应（reply）两部分，中间用---隔开，用到的数据格式由*.msg文件定义。最终编译时需要修改package.xml和CMakeLists.txt文件 2.1. srv示例 以msgs_demo/srv/DetectHuman.srv服务为例，DetectHuman.srv服务取自OpenNI的人体检测ROS软件包，是用来查询当前深度摄像头中的人体姿态和关节数的。 bool start_detect --- my_pkg/HumanPose[] pose_data ---上面的内容是请求方需要发送的数据，即请求的格式 bool格式的数据，是否开始检测 ---下面的内容是服务提供方返回的数据，应答数据 my_pkg/HumanPose[]可变长度数组，pose_data的每个元素都是该人的姿态，数据格式定义在*.msg文件中 2.2. rossrv命令 rossrv 命令 作用 rossrv show 显示服务描述 rossrv list 列出所有服务 rossrv md5 显示服务md5sum rossrv package 列出包中的服务 rossrv packages 列出包含服务的包 "},"ROS/Action.html":{"url":"ROS/Action.html","title":"Action","keywords":"","body":"Action actionlib是ROS中一个很重要的库，类似service通信机制，actionlib也是一种请求响应机制的通信方式，actionlib主要弥补了service通信的一个不足，就是当机器人执行一个长时间的任务时，假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，致使通信受阻。当service通信不能很好的完成任务时候，actionlib则可以比较适合实现长时间的通信过程，actionlib通信过程可以随时被查看过程进度，也可以终止请求，这样的一个特性，使得它在一些特别的机制中拥有很高的效率。 1. Action通信原理 Action的工作原理是client-server模式，也是一个双向的通信模式。通信双方在ROS Action Protocol下通过消息进行数据的交流通信。client和server为用户提供一个简单的API来请求目标（在客户端）或通过函数调用和回调来执行目标（在服务器端）。 相当于Action是对机器人之间的通信进行了一层封装，对于用户程序而言，相当于是直接通信，但是实际上是用户程序和Action Client和Action Server通信 2. Action通信规范 通信过程中涉及到的消息类型 goal 由Action Client向Action Server发送用于设定动作需要用到的相关参数，比如运动目标点的坐标，速度等参数的设定 cancel Action执行的过程中，可以随时由Action Client向Action Server发送取消命令来终止动作任务 status 由Action Server向Action Client发送服务端当前的状态 restult 由Action Server向Action Client发送整个Action的执行结果，这个结果只会发送一次 feedback 由Action Server向Action Client在Action执行过程中的数据，比如执行进度、机器人运动过程中的坐标，可周期性发送 3. action *.action文件和*.srv文件类似，由---对各个部分进行分隔，*.action文件由三部分组成，分别是goal，result和feedback 3.1. action示例 以一个洗碗机的洗碗任务为例说明，goal部分是洗碗机的ID，在请求洗碗任务的时候需要指定洗碗机ID，result部分是最终洗碗的碗的数量，feedback部分是洗碗的进度，百分比表示，能在动作任务执行过程中随时汇报任务进度 # Define the goal uint32 dishwasher_id # Specify which dishwasher we want to use --- # Define the result uint32 total_dishes_cleaned --- # Define a feedback message float32 percent_complete "},"ROS/Parameter-server.html":{"url":"ROS/Parameter-server.html","title":"Parameter server","keywords":"","body":"Parameter Server 1. 简介 参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。参数服务器维护着一个字典，用来存放各个节点的参数和配置信息，它是一种相对静态的通信方式 2. 维护方式 参数服务器中的字典可通过三种方式维护 命令行 launch文件 Node节点源码 2.1. 命令行方式 主要是通过使用rosparam命令来管理 rosparam 命令 作用 rosparam list 列出参数名称 rosparam get param_key 显示参数 rosparam set param_key param_value 设置参数 rosparam delete 删除参数 rosparam load file_name 从文件加载参数 rosparam dump file_name 保存参数到文件 在使用load和dump命令时的文件使用yaml格式 name:'Zhangsan' age:20 gender:'M' score:{Chinese:80,Math:90} score_history:[85,82,88,90] 参考YAML 语言教程 2.2. launch文件 launch文件中有很多标签，而与参数服务器相关的标签只有两个，一个是，另一个是。其中标签只能设置一个参数 通过脚本执行结果设置的值 这里的robot_description的value是用xacro.py执行robot.xacro文件之后的结果，再在启动urdf_spawner节点时的启动参数中加入robot_description这个参数 通过设置 这里标签的作用相当于使用命令行rosparm load xbot2_control.yaml加载yaml文件 直接设置的值 2.3. Node节点源码 通过roscpp或者rospy中提供的相关API直接在节点源码中维护参数的值 "},"ROS/roscpp.html":{"url":"ROS/roscpp.html","title":"roscpp","keywords":"","body":"roscpp 1. Client Library简介 ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。这些接口都可以用来创建topic、service、param，实现ROS的通信功能。Clinet Lirary有点类似开发中的Helper Class，把一些常用的基本功能做了封装。 从开发客户端库的角度看，一个客户端库，至少需要能够包括master注册、名称管理、消息收发等功能。这样才能给开发者提供对ROS通信架构进行配置的方法。 2. roscpp简介 roscpp相当于一个C++库，这个库包括了ROS节点的各种功能实现，roscpp位于/opt/ros/kinetic之下，用C++实现了ROS通信。在ROS中，C++的代码是通过catkin这个编译系统（扩展的CMake）来进行编译构建的。我们创建一个CMake工程，在其中include了roscpp等ROS的libraries，这样就可以在工程中使用ROS提供的函数了。 这个文件里包含了所有roscpp相关的头文件 #include roscpp包含的几个部分如下 ros::init_options命名空间包含节点初始化等功能性的函数 包含ros::init()初始化函数，有三个重载，在使用ROS系统相关功能之前必须调用这个函数 ros::NodeHandle类，句柄主要用来实现和topic、service、param等交互的公共接口 ros::master命名空间包含从master查询信息的函数 ros::this_node命名空间包含查询这个node的函数 ros::service命名空间包含查询服务的函数 ros::param命名空间包含查询参数服务器的函数，而不需要用到NodeHandle ros::names命名空间包含处理ROS图资源名称的函数 关于命名空间的详细解释参考官方wiki "},"ROS/init以及NodeHandle.html":{"url":"ROS/init以及NodeHandle.html","title":"init以及NodeHandle","keywords":"","body":"init以及NodeHandle 1. 节点初始化 ROS程序和其他Cpp程序的主要区别在于 它调用了ros::init()函数，完成了ROS节点的初始化，节点名称等信息 创建了ros::NodeHandle对象，通过这个节点句柄完成ROS通信的一些功能，比如创建Publisher和Subscriber等 句柄（Handle）的概念类似于this指针，NodeHandle相当于是对节点资源的描述，有了这个句柄就可以操作节点的具体功能实现 1.1. ros::init() 函数有三种重载 ROSCPP_DECL void init(int &argc, char **argv, const std::string& name, uint32_t options = 0); ROSCPP_DECL void init(const M_string& remappings, const std::string& name, uint32_t options = 0); ROSCPP_DECL void init(const VP_string& remapping_args, const std::string& name, uint32_t options = 0); argc argv是系统传入参数，在终端运行程序的时候传入 name是节点名字，字符串类型，节点名字需要在同一个ROS系统中保持唯一；如果出现重名，之前的节点会被关闭 options可以设置对节点的具体操作，默认值0，因此在调用的时候可以不指定该参数，具体取值为InitOption枚举体。 当ROS系统中有多个功能相同的节点的时候，可以使用匿名节点，options参数设置为ros::init_options::AnonymousName，在创建节点的时候ROS系统会自动在节点名后加随机数来保证ROS系统中的节点名字唯一 enum InitOption { /** * Don't install a SIGINT handler. You should install your own SIGINT handler in this * case, to ensure that the node gets shutdown correctly when it exits. */ NoSigintHandler = 1 ros::init()函数主要功能是 network::init(remappings); master::init(remappings); this_node::init(name, remappings, options); file_log::init(remappings); param::init(remappings); 参考ROS程序的初始化 1.2. NodeHandle NodeHandle是Node的句柄，用来对当前节点进行各种操作。在ROS中，NodeHandle是一个定义好的类，通过include，我们可以创建这个类，以及使用它的成员函数。各种类型的通信都需要用NodeHandle来创建完成 //创建话题的publisher ros::Publisher advertise(const string &topic, uint32_t queue_size, bool latch=false); //第一个参数为发布话题的名称 //第二个是消息队列的最大长度，如果发布的消息超过这个长度而没有被接收，那么就的消息就会出队。通常设为一个较小的数即可。 //第三个参数是是否锁存。某些话题并不是会以某个频率发布，比如 /map 这个topic，只有在初次订阅或者地图更新这两种情况下，/map才会发布消息。这里就用到了锁存。 //创建话题的subscriber ros::Subscriber subscribe(const string &topic, uint32_t queue_size, void(*)(M)); //第一个参数是订阅话题的名称 //第二个参数是订阅队列的长度，如果受到的消息都没来得及处理，那么新消息入队，旧消息就会出队 //第三个参数是回调函数指针，指向回调函数来处理接收到的消息 //创建服务的server，提供服务 ros::ServiceServer advertiseService(const string &service, bool(*srv_func)(Mreq &, Mres &)); //第一个参数是service名称 //第二个参数是服务函数的指针，指向服务函数。指向的函数应该有两个参数，分别接受请求和响应。 //创建服务的client ros::ServiceClient serviceClient(const string &service_name, bool persistent=false); //第一个函数式service名称 //第二个参数用于设置服务的连接是否持续，如果为true，client将会保持与远程主机的连接，这样后续的请求会快一些。通常我们设为flase //查询某个参数的值 bool getParam(const string &key, std::string &s); bool getParam (const std::string &key, double &d) const； bool getParam (const std::string &key, int &i) const； //从参数服务器上获取key对应的值，已重载了多个类型 //给参数赋值 void setParam (const std::string &key, const std::string &s) const； void setParam (const std::string &key, const char *s) const; void setParam (const std::string &key, int i) const; //给key对应的val赋值，重载了多个类型的val 2. 节点关闭 通常我们要关闭一个节点可以直接在终端上按Ctrl+C，系统会自动触发SIGINT句柄来关闭这个进程。 你也可以通过调用ros::shutdown()来手动关闭节点，但通常我们很少这样做。默认情况下终端中使用Ctrl+C，最终会调用ros::shutdown()，对于一些在退出时需要其他操作的节点，也可以自定义退出的操作，具体参考ROS节点的初始化及退出详解 #include int main(int argc, char** argv) { ros::init(argc, argv, \"your_node_name\"); ros::NodeHandle nh; //....节点功能 //.... ros::spin();//用于触发topic、service的响应队列 return 0; } "},"ROS/topic-in-roscpp.html":{"url":"ROS/topic-in-roscpp.html","title":"topic in roscpp","keywords":"","body":"topic in roscpp topic和msg相关解释 以topic_demo为例，自定义一个gps类型的消息（包括x, y, state），一个节点以一定频率模拟发布gps信息，另一个节点进行消息接收并计算出当前位置与原点(0, 0)的欧氏距离 1. 创建消息 新建topic_demo/msg/gps.msg文件 float32 x # x坐标 float32 y # y坐标 string state # 工作状态 程序中对消息的操作方法类似于对结构体的操作。 2. 创建节点 2.1. 消息发布节点 topic_demo/src/talker.cpp文件 #include #include int main(int argc, char **argv) { //用于解析ROS参数，第三个参数为本节点名 ros::init(argc, argv, \"talker\"); //实例化句柄，初始化node ros::NodeHandle nh; //自定义gps msg topic_demo::gps msg; msg.x = 1.0; msg.y = 1.0; msg.state = \"working\"; //创建publisher ros::Publisher pub = nh.advertise(\"gps_info\", 1); //定义发布的频率 ros::Rate loop_rate(1.0); //循环发布msg while (ros::ok()) { //以指数增长，每隔1秒更新一次 msg.x *= 1.03; msg.y *= 1.01; ROS_INFO(\"Talker: GPS: x = %f, y = %f \", msg.x ,msg.y); //以1Hz的频率发布msg pub.publish(msg); //根据前面定义的频率, sleep 1s loop_rate.sleep();//根据前面的定义的loop_rate,设置1s的暂停 } return 0; } 节点句柄的advertise函数是模板函数，因此在创建ros::Publisher对象时需要指定消息类型为topic_demo::gps，指定pub的发布主题为gps_info，发送队列大小为1 topic_demo::gps这个消息的命名空间为topic_demo的原因是CMakeLists.txt中定义的项目名是topic_demo 2.2. 消息接收节点 2.2.1. topic_demo/src/listener.cpp文件 #include #include #include void gpsCallback(const topic_demo::gps::ConstPtr &msg) { //计算离原点(0,0)的距离 std_msgs::Float32 distance; distance.data = sqrt(pow(msg->x,2)+pow(msg->y,2)); //float distance = sqrt(pow(msg->x,2)+pow(msg->y,2)); ROS_INFO(\"Listener: Distance to origin = %f, state: %s\",distance.data,msg->state.c_str()); } int main(int argc, char **argv) { ros::init(argc, argv, \"listener\"); ros::NodeHandle n; ros::Subscriber sub = n.subscribe(\"gps_info\", 1, gpsCallback); //ros::spin()用于调用所有可触发的回调函数。将进入循环，不会返回，类似于在循环里反复调用ros::spinOnce()。 ros::spin(); return 0; } 在新建ros::Subscriber对象的时候需要指定主题名、接收队列大小、回调函数的函数指针，这里的gpsCallback函数是回调函数的函数指针，只有sub收到消息的时候才会调用该函数。 具体去触发回调函数的命令就是ros::spin()，它会反复的查看有没有消息来，如果有就会让回调函数去处理。若只指定了callback函数，而不进行ros::spin()或者ros::spinOnce()最终也回调函数不会生效 2.2.2. 消息队列处理 Subscriber接收到消息，实际上是先把消息放到一个队列中去。队列的长度在Subscriber构建的时候设置好了。当有spin函数执行，就会去处理消息队列中队首的消息。 spin方法 阻塞/非阻塞 单线程/多线程 ros::spin() 阻塞 单线程 ros::spinOnce() 非阻塞 单线程 ros::MultiThreadedSpin() 阻塞 多线程 ros::AsyncMultiThreadedSpin() 非阻塞 多线程 阻塞类的spin函数执行的时候相当于程序进入了一个死循环，一直检查是否有新的消息入队，消息的处理通过回调函数来执行，因此正常情况下在阻塞类的spin函数之后的代码不会执行。 单线程与多线程的消息处理示意图如下 3. 项目结构文件 3.1. topic_demo/CMakeLists.txt文件 cmake_minimum_required(VERSION 2.8.3) project(topic_demo) find_package(catkin REQUIRED COMPONENTS roscpp std_msgs message_generation ) add_message_files(FILES gps.msg ) generate_messages(DEPENDENCIES std_msgs ) add_executable(talker src/talker.cpp) #生成可执行文件talker # add_dependencies(talker topic_demo_generate_messages_cpp) add_dependencies(talker ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) # 表明在编译talker前，必须先生编译完成自定义消息 # 必须添加add_dependencies，否则找不到自定义的msg产生的头文件 # 表明在编译talker前，必须先生编译完成自定义消息 target_link_libraries(talker ${catkin_LIBRARIES}) #链接 add_executable(listener src/listener.cpp ) #声称可执行文件listener add_dependencies(listener ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(listener ${catkin_LIBRARIES})#链接 ROS的消息的格式即msg文件是ROS自行定义的，并不是Cpp的标准，因此需要依赖message_generation功能包来将gps.msg文件“编译”成符合Cpp标准的形式的结构体、头文件等 消息中用到的float32和string并不是Cpp的标准格式，而是ROS系统提供的格式，因此需要依赖std_msgs包 generate_messages()是用来生成msg的，如果没有这行，在源程序中会找不到gps.h，也就是没有生成消息结构体 参考ROS 机器人技术 - 解析 CMakeList.txt 文件 3.2. topic_demo/package.xml文件 topic_demo 0.1.0 This package topic_demo someone mit catkin roscpp std_msgs message_generation message_runtime 在编译的时候需要用到message_generation依赖 在节点运行的时候需要用到message_runtime依赖，提供消息运行时需要的依赖 xml文件的必填项参考package.xml "},"ROS/service-in-roscpp.html":{"url":"ROS/service-in-roscpp.html","title":"service in roscpp","keywords":"","body":"service in roscpp Service和srv相关解释 以service_demo为例，定义Greeting.srv服务，接收姓名和年龄，返回一个字符串。一个节点发出服务请求，另一个节点提供服务，返回问候语 1. 创建服务 1.1. Greeting.srv文件 string name #短横线上边部分是服务请求的数据 int32 age --- #短横线下面是服务回传的内容。 string feedback 对于Greeting.srv而言，最终也被编译成Greeting结构体，在service_demo命名空间下 服务的两部分Request和Response是两个结构体，并且被嵌套在Greeting结构体下 2. 创建节点 2.1. server节点 service_demo/src/server.cpp文件 # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" # include \"string\" // 定义请求处理函数 bool handle_function(service_demo::Greeting::Request &req, service_demo::Greeting::Response &res) { // 此处我们对请求直接输出 ROS_INFO(\"Request from %s with age %d \", req.name.c_str(), req.age); // 返回一个反馈，将response设置为\"...\" res.feedback = \"Hi \" + req.name + \". I'm server!\"; return true; } int main(int argc, char **argv) { // 初始化节点，命名为\"greetings_server\" ros::init(argc, argv, \"greetings_server\"); // 定义service的server端，service名称为“greetings”，收到request请求之后传递给handle_function进行处理 ros::NodeHandle nh; ros::ServiceServer service = nh.advertiseService(\"greetings\", handle_function); // 调用可 ros::spin(); return 0; } 服务端对外提供服务，通过nh句柄创建service，advertiseService()有两个参数，服务名和处理函数 当server节点收到服务请求时会调用handle_function() handle_function()的两个参数是Greeting的Request和Response两部分的引用，返回值是布尔型，是否成功执行 需要调用ros::spin();进行消息队列处理 2.2. client节点 service_demo/src/client.cpp文件 # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" int main(int argc, char **argv) { // 初始化，节点命名为\"greetings_client\" ros::init(argc, argv, \"greetings_client\"); // 定义service客户端，service名字为“greetings”，service类型为service_demo ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient(\"greetings\"); // 实例化srv，设置其request消息的内容，这里request包含两个变量，name和age，见Greeting.srv service_demo::Greeting srv; srv.request.name = \"HAN\"; srv.request.age = 20; if (client.call(srv)) { // 注意我们的response部分中的内容只包含一个变量response，另，注意将其转变成字符串 ROS_INFO(\"Response from server: %s\", srv.response.feedback.c_str()); } else { ROS_ERROR(\"Failed to call service Service_demo\"); return 1; } return 0; } 通过nh句柄创建ros::ServiceClient对象的时候需要指定服务结构体和服务名，这里说的服务名是server节点在创建服务的时候起的名字 通过client.call()请求服务，参数为service_demo::Greeting的实例 srv.response.feedback是string类对象，在输出时通过c_str()成员函数转换为字符数组。参考C++中c_str()函数的用法 3. 项目结构文件 3.1. CMakeLists.txt cmake_minimum_required(VERSION 2.8.3) project(service_demo) find_package(catkin REQUIRED COMPONENTS roscpp std_msgs message_generation # 需要添加的地方 ) add_service_files( FILES Greeting.srv ) generate_messages(DEPENDENCIES std_msgs ) include_directories( include ${catkin_INCLUDE_DIRS} ) add_executable(server src/server.cpp) add_dependencies(server ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(server ${catkin_LIBRARIES}) add_executable(client src/client.cpp) add_dependencies(client ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(client ${catkin_LIBRARIES}) 和消息一样，新建服务也需要generate_messages()否则在代码中greeting.h头文件会报错 3.2. packages.xml service_demo 0.1.0 This package service_demo someone mit catkin roscpp std_msgs message_generation message_runtime "},"ROS/param-in-roscpp.html":{"url":"ROS/param-in-roscpp.html","title":"param in roscpp","keywords":"","body":"param in roscpp Parameter server 相关解释 roscpp为参数服务器的维护提供了两套api ros::param命名空间下的函数 ros::NodeHandle类的成员函数 1. param_demo param_demo/src/param.cpp文件 #include int main(int argc, char **argv){ ros::init(argc, argv, \"param_demo\"); ros::NodeHandle nh; int parameter1, parameter2, parameter3, parameter4, parameter5; //Get Param的三种方法 //ros::param::get()获取参数“param1”的value，写入到parameter1上 bool ifget1 = ros::param::get(\"param1\", parameter1); //ros::NodeHandle::getParam()获取参数 bool ifget2 = nh.getParam(\"param2\",parameter2); //如果get不到指定的param，它可以给parameter3指定一个默认值(如33333) nh.param(\"param3\", parameter3, 33333); if(ifget1) ROS_INFO(\"Get param1 = %d\", parameter1); else ROS_WARN(\"Didn't retrieve param1\"); if(ifget2) ROS_INFO(\"Get param2 = %d\", parameter2); else ROS_WARN(\"Didn't retrieve param2\"); if(nh.hasParam(\"param3\")) ROS_INFO(\"Get param3 = %d\", parameter3); else ROS_WARN(\"Didn't retrieve param3\"); //Set Param的两种方法 //ros::param::set()设置参数 parameter4 = 4; ros::param::set(\"param4\", parameter4); //ros::NodeHandle::setParam()设置参数 parameter5 = 5; nh.setParam(\"param5\",parameter5); ROS_INFO(\"Param4 is set to be %d\", parameter4); ROS_INFO(\"Param5 is set to be %d\", parameter5); //Check Param的两种方法 //ros::NodeHandle::hasParam() bool ifparam5 = nh.hasParam(\"param5\"); //ros::param::has() bool ifparam6 = ros::param::has(\"param6\"); if(ifparam5) ROS_INFO(\"Param5 exists\"); else ROS_INFO(\"Param5 doesn't exist\"); if(ifparam6) ROS_INFO(\"Param6 exists\"); else ROS_INFO(\"Param6 doesn't exist\"); //Delete Param的两种方法 //ros::NodeHandle::deleteParam() bool ifdeleted5 = nh.deleteParam(\"param5\"); //ros::param::del() bool ifdeleted6 = ros::param::del(\"param6\"); if(ifdeleted5) ROS_INFO(\"Param5 deleted\"); else ROS_INFO(\"Param5 not deleted\"); if(ifdeleted6) ROS_INFO(\"Param6 deleted\"); else ROS_INFO(\"Param6 not deleted\"); ros::Rate rate(0.3); while(ros::ok()){ int parameter = 0; ROS_INFO(\"=============Loop==============\"); //roscpp中尚未有ros::param::getallparams()之类的方法 if(ros::param::get(\"param1\", parameter)) ROS_INFO(\"parameter param1 = %d\", parameter); if(ros::param::get(\"param2\", parameter)) ROS_INFO(\"parameter param2 = %d\", parameter); if(ros::param::get(\"param3\", parameter)) ROS_INFO(\"parameter param3 = %d\", parameter); if(ros::param::get(\"param4\", parameter)) ROS_INFO(\"parameter param4 = %d\", parameter); if(ros::param::get(\"param5\", parameter)) ROS_INFO(\"parameter param5 = %d\", parameter); if(ros::param::get(\"param6\", parameter)) ROS_INFO(\"parameter param6 = %d\", parameter); rate.sleep(); } } param_demo/launch/param_demo_cpp.launch文件 param3: 3 param4: 4 param5: 5 2. 运行结果 执行rosrun param_demo param_demo的结果如下 [ WARN] [1611930965.096364533]: Didn't retrieve param1 [ WARN] [1611930965.096428485]: Didn't retrieve param2 [ WARN] [1611930965.097569665]: Didn't retrieve param3 [ INFO] [1611930965.099216747]: Param4 is set to be 4 [ INFO] [1611930965.099250417]: Param5 is set to be 5 [ INFO] [1611930965.100457062]: Param5 exists [ INFO] [1611930965.100498410]: Param6 doesn't exist [ INFO] [1611930965.102516533]: Param5 deleted [ INFO] [1611930965.102558813]: Param6 not deleted [ INFO] [1611930965.102579994]: =============Loop============== [ INFO] [1611930965.104550994]: parameter param4 = 4 [ INFO] [1611930968.438369688]: =============Loop============== [ INFO] [1611930968.441288282]: parameter param4 = 4 param1 2定义在launch文件中，直接通过rosrun打开节点的话，没有加载launch文件中对这几个参数的定义，所以节点无法读取参数 param3 读取的时候参数服务器中并没有这个参数，但是针对param3的读取方法是nh.param(\"param3\", parameter3, 33333);，这个参数的第三个变量是默认值，因此如若参数服务器中没有param3这个参数，会给parameter3变量赋默认值33333 template bool param(const std::string& param_name, T& param_val, const T& default_val) const { if (hasParam(param_name)) { if (getParam(param_name, param_val)) { return true; } } param_val = default_val; return false; } 执行roslaunch param_demo param_demo_cpp.launch的结果如下 process[param_demo-1]: started with pid [29494] [ INFO] [1611929812.346775227]: Get param1 = 1 [ INFO] [1611929812.346835230]: Get param2 = 2 [ INFO] [1611929812.347514679]: Get param3 = 3 [ INFO] [1611929812.349519691]: Param4 is set to be 4 [ INFO] [1611929812.349576397]: Param5 is set to be 5 [ INFO] [1611929812.351273386]: Param5 exists [ INFO] [1611929812.351307720]: Param6 doesn't exist [ INFO] [1611929812.353115211]: Param5 deleted [ INFO] [1611929812.353152792]: Param6 not deleted [ INFO] [1611929812.353196434]: =============Loop============== [ INFO] [1611929812.354020600]: parameter param1 = 1 [ INFO] [1611929812.354780836]: parameter param2 = 2 [ INFO] [1611929812.355424684]: parameter param3 = 3 [ INFO] [1611929812.356337908]: parameter param4 = 4 [ INFO] [1611929815.688232581]: =============Loop============== [ INFO] [1611929815.689976152]: parameter param1 = 1 [ INFO] [1611929815.691289476]: parameter param2 = 2 [ INFO] [1611929815.692041662]: parameter param3 = 3 [ INFO] [1611929815.692681417]: parameter param4 = 4 "},"ROS/命名空间.html":{"url":"ROS/命名空间.html","title":"命名空间","keywords":"","body":"命名空间 1. 名称（Names） 在ROS系统中的一个对象就是一个图（也称计算图computation graph）以下都可以称为图 Nodes: A node is an executable that uses ROS to communicate with other nodes. Messages: ROS data type used when subscribing or publishing to a topic. Topics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages. Master: Name service for ROS (i.e. helps nodes find each other) rosout: ROS equivalent of stdout/stderr roscore: Master + rosout + parameter server (parameter server will be introduced later) 这些图的命名有一定的规则，图的名字是层级化的，由一系列命名空间构成，这样就可以保证名字的唯一性，在ROS中有4中不同的图资源名 base（基本名称） relative/name （相对名称） /global/name （全局名称） ~private/name （私有名称） 在默认的情况下，对于名字的解析是相对于节点的命名空间完成的 名称 解释 相对名称 相对名称的解析是依赖默认命名空间的。如默认命名空间为”/” 则名称“A/B”被解析为”/A/B”。 基本名称 基本名称是没有命名空间限定符的相对名称（即没有/号）。 全局名称 以“/”开头的名称称为全局名称，代表该名称属于全局命名空间。意思是在ROS系统的任何地方都可以使用。无论在ROS系统的任何地方它都以明确的意义。 私有名称 私有名称以”~”开头，它与相对图名称的区别是，它的解析不依赖与默认命名空间，而是依赖包名称。 作为一个开源的、分布式的机器人操作系统，众多开发者开发的包并不能保证所有定义的资源命名都不同，一旦含有相同的名称的资源的包在一个ROS网络中运行，就会发生冲突。因此，在实际的ROS网络中，各个节点、话题、消息和参数的名称必须是唯一的，不然就会发生冲突，这很容易理解。区分相同名字的资源的两种方法 给两个名字前加上定语，就是添加命名空间 给两个名字取个不同的别名，就是重映射 参考 ROS之命名空间 ROS学习 之 命名空间（NameSpace）、重映射（Remapping）、名称（Names） ROS的命名空间与重映射 2. param 在这一个launch文件中有两个名为serial的参数，但这两个参数值不同，使用不同作用域的NodeHandle句柄可以对这两个参数分别读写 #include int main(int argc, char* argv[]) { int serial_number = -1;//serial_number初始化 ros::init(argc, argv, \"name_demo\");//node初始化 /*创建命名空间*/ //n 是全局命名空间 ros::NodeHandle n; //nh 是局部命名空间 ros::NodeHandle nh(\"~\"); //提取全局命名空间下的参数serial n.getParam(\"serial\", serial_number); //在全局命名空间下，要提取全局命名空间下的参数，直接写参数名 ROS_INFO(\"n.getParam(\\\"serial\\\", serial_number); --- global_Serial was %d\", serial_number); nh.getParam(\"/serial\", serial_number); //在局部命名空间下，要提取全局命名空间下的参数，需要添加“/” ROS_INFO(\"nh.getParam(\\\"/serial\\\", serial_number); --- local_to_global_Serial was %d\", serial_number); std::cout 在实例化NodeHandle句柄的时候会ros::NodeHandle n;和ros::NodeHandle nh(\"~\");有两种方式，这就区分出了全局命名空间和局部命名空间 roslaunch name_demo demo.launch执行结果 process[name_demo-1]: started with pid [7424] [ INFO] [1611980559.624305272]: n.getParam(\"serial\", serial_number); --- global_Serial was 5 [ INFO] [1611980559.625404705]: nh.getParam(\"/serial\", serial_number); --- local_to_global_Serial was 5 -------------------------------------------- [ INFO] [1611980559.626021242]: n.getParam(\"name_demo/serial\", serial_number); --- global_to_local_Serial was 10 [ INFO] [1611980559.626655962]: nh.getParam(\"serial\", serial_number); --- local_Serial was 10 3. topic ros::init(argc, argv, \"listener\"); ros::NodeHandle n(); ros::NodeHandle nh1(\"~\"); ros::NodeHandle nh2(\"~foo\"); ros::Subscriber sub = n.subscribe(\"gps_info\", ...); ros::Subscriber sub1 = nh1.subscribe(\"gps_info\", ...); ros::Subscriber sub2 = nh2.subscribe(\"gps_info\", ...); rostopic list的执行结果如下 /gps_info /listener/foo/gps_info /listener/gps_info /rosout /rosout_agg n句柄在创建的时候没有指定命名空间，所以默认为全局命名空间，因此sub订阅的话题是/gps_info nh1句柄在创建的时候指定私有命名空间，所以使用nh1句柄进行的操作都是在/listener命名空间下的，因此sub订阅的话题是/listener/gps_info nh2句柄在创建的时候指定~foo命名空间，所以使用nh2句柄进行的操作都是在/listener/foo命名空间下的，因此sub订阅的话题是/listener/foo/gps_info 很明显这三个topic虽然在订阅的时候名字都是gps_info，但实际上这是三个不同的topic "},"ROS/roscpp时钟.html":{"url":"ROS/roscpp时钟.html","title":"roscpp时钟","keywords":"","body":"时钟 1. Time与Duration 在ROS里面对于机器人的控制会经常使用到关于时间的功能，设定程序等待时间、设定定时器等。roscpp提供了两种时间表示方法 时刻ros::Time 时间ros::Duration Time和Duration都由秒和纳秒组成。表示方法为 int32 sec int32 nsec 在使用这两种功能时需要引用相应的头文件#include 和#include ros::Time begin = ros::Time::now(); //获取当前时间 ros::Time at_some_time1(5, 20000000); //5.2s ros::Time at_some_time2(5.2) //同上，重载了float类型和两个uint类型的构造函数 ros::Duration one_hour(60 * 60, 0); //1h double secs1 = at_some_time1.toSec();//将Time转为double型时间 double secs2 = one_hour.toSec();//将Duration转为double型时间 时间和持续时间算术运算 1 hour + 1 hour = 2 hours (duration + duration = duration) 2 hours - 1 hour = 1 hour (duration - duration = duration) Today + 1 day = tomorrow (time + duration = time) Today - tomorrow = -1 day (time - time = duration) Today + tomorrow = error (time + time is undefined) ros::Time t1 = ros::Time::now() - ros::Duration(5.5); //t1是5.5s前的时刻，Time加减Duration返回都是Time ros::Time t2 = ros::Time::now() + ros::Duration(3.3); //t2是当前时刻往后推3.3s的时刻 ros::Duration d1 = t2 - t1; //从t1到t2的时长，两个Time相减返回Duration类型 ros::Duration d2 = d1 -ros::Duration(0,300); //两个Duration相减，还是Duration 2. Sleeping 和 Rates bool ros::Duration::sleep()可以设置延迟一段时间，比如 ros::Duration(0.5).sleep(); //用Duration对象的sleep方法休眠 ros::Duration one_second(1, 0); one_second.sleep(); //休眠1秒 ros::Rate类可以设置频率 ros::Rate r(10); // 10 hz while (ros::ok()) { // ... do some work ... r.sleep(); } 3. Timer Rate的作用是指定一个频率，与之类似的是ROS中的定时器Timer，它是通过设定回调函数和触发时间来实现某些动作的反复执行，就和传统意义上的定时器功能一致 ros::Timer是一个类，使用时添加#include \"ros/ros.h\"即可，定时器也是需要通过使用节点句柄来创建 void callback1(const ros::TimerEvent&) { ROS_INFO(\"Callback 1 triggered\"); } void callback2(const ros::TimerEvent&) { ROS_INFO(\"Callback 2 triggered\"); } int main(int argc, char **argv) { ros::init(argc, argv, \"talker\"); ros::NodeHandle n; ros::Timer timer1 = n.createTimer(ros::Duration(0.1), callback1); //timer1每0.1s触发一次callback1函数 ros::Timer timer2 = n.createTimer(ros::Duration(1.0), callback2); //timer2每1.0s触发一次callback2函数 ros::spin(); //千万别忘了spin，只有spin了才能真正去触发回调函数 return 0; } 回调函数中的TimerEvent结构体 struct TimerEvent { Time last_expected; /// "},"ROS/日志和异常.html":{"url":"ROS/日志和异常.html","title":"日志和异常","keywords":"","body":"日志和异常 1. 日志 ROS系统中的日志系统是基于topic的，所有的日志信息都输出到/rosout话题上，rosout本身也是一个节点，负责处理ROS系统中的所有日志信息，会在启动master的时候自动启动 ROS的日志分为5个等级 DEBUG INFO WARN ERROR FATAL 用法类似printf()函数，支持格式化输出 ROS_DEBUG(\"The velocity is %f\", vel); ROS_WARN(\"Warn: the use is deprecated.\"); ROS_FATAL(\"Cannot start this node.\"); ... 关于日志详细介绍参考ROS与C++入门教程-Logging(日志) 2. 异常 roscpp所有的异常都继承基类ros::Exception，roscpp中有两种异常类型，当有以下两种错误时，就会抛出异常： 当无效的基础名称传给ros::init(),通常是名称中有/,就会触发 ros::InvalidNodeNameException 当无效名称传给了roscpp ros::InvalidNameExcaption "},"ROS/rospy.html":{"url":"ROS/rospy.html","title":"rospy","keywords":"","body":"rospy rospy是Python版本的ROS客户端库，提供了Python编程需要的接口，可以认为rospy就是一个Python的模块(Module)。这个模块位于/opt/ros/kineetic/lib/python2.7/dist-packages/rospy之中。 rospy包含的功能与roscpp相似，都有关于node、topic、service、param、time相关的操作。rospy没有一个NodeHandle，像创建publisher、subscriber等操作都被直接封装成了rospy中的函数或类，调用起来简单直观。 ROS中绝大多数基本指令，例如rostopic, roslaunch都是用python开发的，简单轻巧。 1. rospy代码组织形式 对于一些小体量的代码，直接把*.py文件放到src/script/目录下即可 robot_sim_demo ├── CMakeLists.txt ├── package.xml ... └── scripts └── robot_keyboard_teleop.py 对于一些体量较大的项目，在src下建立一个与你的package同名的路径，其中存放__init__.py以及你的模块文件 robot_sim_demo ├── CMakeLists.txt ├── package.xml ... ├── scripts │ └── robot_keyboard_teleop.py └── src └── robot_sim_demo ├── a.py ├── b.py └── __init__.py __init__.py可以将其所在目录变为一个python包，可以在其他的*.py文件中import这个包，即可使用这个包的功能代码。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。 参考Python init.py作用详解 2. init和node相关 参考init以及NodeHandle 返回值 方法 作用 rospy.init_node(name, argv=None, anonymous=False) 注册和初始化node MasterProxy rospy.get_master() 获取master的句柄 bool rospy.is_shutdown() 节点是否关闭 rospy.on_shutdown(fn) 在节点关闭时调用fn函数 str get_node_uri() 返回节点的URI str get_name() 返回本节点的全名 str get_namespace() 返回本节点的名字空间 3. topic in rospy 参考topic in roscpp learn_topic/src/scripts/py-listener.py #!/usr/bin/env python #coding=utf-8 import rospy import math from learn_topic.msg import gps # 回调函数输入的应该是msg def callback(gps): distance = math.sqrt(math.pow(gps.x, 2)+math.pow(gps.y, 2)) rospy.loginfo('Listener: GPS: distance=%f, state=%s', distance, gps.state) def listener(): rospy.init_node('pylistener', anonymous=True) # Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型，第三个参数是回调函数的名称 rospy.Subscriber('gps_info', gps, callback) rospy.spin() if __name__ == '__main__': listener() learn_topic/src/scripts/py-talker.py #!/usr/bin/env python #coding=utf-8 import rospy #倒入自定义的数据类型 from learn_topic.msg import gps def talker(): #Publisher 函数第一个参数是话题名称，第二个参数是数据类型，现在就是我们定义的msg，最后一个是缓冲区的大小 pub = rospy.Publisher('gps_info', gps , queue_size=10) rospy.init_node('pytalker', anonymous=True) #更新频率是1hz rate = rospy.Rate(1) x=1.0 y=2.0 state='working' while not rospy.is_shutdown(): #计算距离 rospy.loginfo('Talker: GPS: x=%f ,y= %f',x,y) pub.publish(gps(state,x,y)) x=1.03*x y=1.01*y rate.sleep() if __name__ == '__main__': talker() rospy和roscpp，对于消息（*.msg）的定义都是相同的，都需要在CMakeLists.txt和package.xml添加相应的依赖，但是又有所不同。 如果package中只包含python代码，则CMakeLists.txt中不需要使用add_executable()，仅添加相应的msg、rospy等依赖包即可 对于scripts/目录下的脚本文件需要有可执行的权限chmod +x *.py添加执行权限。如果没有执行权限，rosrun无法运行 4. service in rospy 参考service in roscpp learn_service/src/sctipts/py-server.py #!/usr/bin/env python #coding=utf-8 import rospy from learn_service.srv import * def handle_function(req): rospy.loginfo( 'Request from %s with age %d', req.name, req.age) return GreetingResponse(\"Hi %s. I' server!\"%req.name) def server_srv(): rospy.init_node(\"greetings_server\") s = rospy.Service(\"greetings\", Greeting, handle_function) rospy.loginfo(\"Ready to handle the request:\") # 阻塞程序结束 rospy.spin() if __name__==\"__main__\": server_srv() 在调用rospy.Service()函数的时候，回调函数handle的参数是*.srv文件中的request部分 handle_function()函数的返回值是*.srv文件中的respond部分，类型为对象，本例中的Greeting.srv文件中respond部分为一字符串 learn_service/src/sctipts/py-client.py #!/usr/bin/env python # coding:utf-8 import rospy from learn_service.srv import * def client_srv(): rospy.init_node('greetings_client') # 等待有可用的服务 \"greetings\" rospy.wait_for_service(\"greetings\") try: greetings_client = rospy.ServiceProxy(\"greetings\", Greeting) # resp = greetings_client(name=\"LI\", age=11) req = GreetingRequest(name=\"LI\", age=11) resp = greetings_client.call(req) # 打印处理结果，注意调用response的方法，类似于从resp对象中调取response属性 rospy.loginfo(\"Message From server:%s\"%resp.feedback) except rospy.ServiceException, e: rospy.logwarn(\"Service call failed: %s\"%e) if __name__==\"__main__\": client_srv() 在请求服务的时候greetings_client.call(req)请求参数req是Greeting.srv的request部分，函数的返回值是服务请求的respond 以下请求服务效果相同 greetings_client(name=\"HAN\", age=20) greetings_client.call(name=\"HAN\", age=20) 如代码所示构造GreetingRequest类，再传入greetings_client()方法 5. param 参考param in roscpp #!/usr/bin/env python # coding:utf-8 import rospy def param_demo(): rospy.init_node(\"param_demo\") rate = rospy.Rate(1) while(not rospy.is_shutdown()): parameter1 = rospy.get_param(\"/param1\") parameter2 = rospy.get_param(\"/param2\", default=222) rospy.loginfo('Get param1 = %d', parameter1) rospy.loginfo('Get param2 = %d', parameter2) rospy.delete_param('/param2') rospy.set_param('/param2',2) ifparam3 = rospy.has_param('/param3') if(ifparam3): rospy.loginfo('/param3 exists') else: rospy.loginfo('/param3 does not exist') params = rospy.get_param_names() rospy.loginfo('param list: %s', params) rate.sleep() if __name__==\"__main__\": param_demo() rospy比roscpp多了一个rospy.get_param_names()，能返回当前ros中的所有参数，返回值为python中的列表类型 6. 时钟 参考roscpp时钟 6.1. Time和Duration rospy中的关于时钟的操作和roscpp是一致的，都有Time、Duration和Rate三个类。 time_now1 = rospy.get_rostime() #当前时刻的Time对象 返回Time对象 time_now2 = rospy.Time.now() #同上 time_now3 = rospy.get_time() #得到当前时间，返回float 单位秒 time_4 = rospy.Time(5) #创建5s的时刻 duration = rospy.Duration(3*60) #创建3min时长 关于Time、Duration之间的加减法和类型转换，和roscpp中的完全一致，参考 6.2. sleep duration.sleep() #挂起 rospy.sleep(duration) #同上，这两种方式效果完全一致 loop_rate = Rate(5) #利用Rate来控制循环频率 while(rospy.is_shutdown()): loop_rate.sleep() #挂起，会考虑上次loop_rate.sleep的时间 6.3. Timer rospy里的定时器和roscpp中的也类似，只不过不是用句柄来创建，而是直接rospy.Timer(Duration, callback)，第一个参数是时长，第二个参数是回调函数。 def my_callback(event): print 'Timer called at ' + str(event.current_real) rospy.Timer(rospy.Duration(2), my_callback) #每2s触发一次callback函数 rospy.spin() 回调函数的传入值是TimerEvent类型，和roscpp中的TimerEvent结构体基本相同 class TimerEvent(object): \"\"\" Constructor. @param last_expected: in a perfect world, this is when the previous callback should have happened @type last_expected: rospy.Time @param last_real: when the callback actually happened @type last_real: rospy.Time @param current_expected: in a perfect world, this is when the current callback should have been called @type current_expected: rospy.Time @param last_duration: contains the duration of the last callback (end time minus start time) in seconds. Note that this is always in wall-clock time. @type last_duration: float \"\"\" def __init__(self, last_expected, last_real, current_expected, current_real, last_duration): self.last_expected = last_expected self.last_real = last_real self.current_expected = current_expected self.current_real = current_real self.last_duration = last_duration "}}